{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return']) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n  };\n}();\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _inlineStylePrefixerStatic = require('inline-style-prefixer/static');\n\nvar _inlineStylePrefixerStatic2 = _interopRequireDefault(_inlineStylePrefixerStatic);\n\nvar _util = require('./util');\n/**\r\n * Generate CSS for a selector and some styles.\r\n *\r\n * This function handles the media queries, pseudo selectors, and descendant\r\n * styles that can be used in aphrodite styles.\r\n *\r\n * @param {string} selector: A base CSS selector for the styles to be generated\r\n *     with.\r\n * @param {Object} styleTypes: A list of properties of the return type of\r\n *     StyleSheet.create, e.g. [styles.red, styles.blue].\r\n * @param stringHandlers: See `generateCSSRuleset`\r\n * @param useImportant: See `generateCSSRuleset`\r\n *\r\n * To actually generate the CSS special-construct-less styles are passed to\r\n * `generateCSSRuleset`.\r\n *\r\n * For instance, a call to\r\n *\r\n *     generateCSSInner(\".foo\", {\r\n *       color: \"red\",\r\n *       \"@media screen\": {\r\n *         height: 20,\r\n *         \":hover\": {\r\n *           backgroundColor: \"black\"\r\n *         }\r\n *       },\r\n *       \":active\": {\r\n *         fontWeight: \"bold\",\r\n *         \">>bar\": {\r\n *           _names: { \"foo_bar\": true },\r\n *           height: 10,\r\n *         }\r\n *       }\r\n *     });\r\n *\r\n * will make 5 calls to `generateCSSRuleset`:\r\n *\r\n *     generateCSSRuleset(\".foo\", { color: \"red\" }, ...)\r\n *     generateCSSRuleset(\".foo:active\", { fontWeight: \"bold\" }, ...)\r\n *     generateCSSRuleset(\".foo:active .foo_bar\", { height: 10 }, ...)\r\n *     // These 2 will be wrapped in @media screen {}\r\n *     generateCSSRuleset(\".foo\", { height: 20 }, ...)\r\n *     generateCSSRuleset(\".foo:hover\", { backgroundColor: \"black\" }, ...)\r\n */\n\n\nvar generateCSS = function generateCSS(selector, styleTypes, stringHandlers, useImportant) {\n  var merged = styleTypes.reduce(_util.recursiveMerge);\n  var declarations = {};\n  var mediaQueries = {};\n  var pseudoStyles = {};\n  Object.keys(merged).forEach(function (key) {\n    if (key[0] === ':') {\n      pseudoStyles[key] = merged[key];\n    } else if (key[0] === '@') {\n      mediaQueries[key] = merged[key];\n    } else {\n      declarations[key] = merged[key];\n    }\n  });\n  return generateCSSRuleset(selector, declarations, stringHandlers, useImportant) + Object.keys(pseudoStyles).map(function (pseudoSelector) {\n    return generateCSSRuleset(selector + pseudoSelector, pseudoStyles[pseudoSelector], stringHandlers, useImportant);\n  }).join(\"\") + Object.keys(mediaQueries).map(function (mediaQuery) {\n    var ruleset = generateCSS(selector, [mediaQueries[mediaQuery]], stringHandlers, useImportant);\n    return mediaQuery + '{' + ruleset + '}';\n  }).join(\"\");\n};\n\nexports.generateCSS = generateCSS;\n/**\r\n * Helper method of generateCSSRuleset to facilitate custom handling of certain\r\n * CSS properties. Used for e.g. font families.\r\n *\r\n * See generateCSSRuleset for usage and documentation of paramater types.\r\n */\n\nvar runStringHandlers = function runStringHandlers(declarations, stringHandlers) {\n  var result = {};\n  Object.keys(declarations).forEach(function (key) {\n    // If a handler exists for this particular key, let it interpret\n    // that value first before continuing\n    if (stringHandlers && stringHandlers.hasOwnProperty(key)) {\n      result[key] = stringHandlers[key](declarations[key]);\n    } else {\n      result[key] = declarations[key];\n    }\n  });\n  return result;\n};\n/**\r\n * Generate a CSS ruleset with the selector and containing the declarations.\r\n *\r\n * This function assumes that the given declarations don't contain any special\r\n * children (such as media queries, pseudo-selectors, or descendant styles).\r\n *\r\n * Note that this method does not deal with nesting used for e.g.\r\n * psuedo-selectors or media queries. That responsibility is left to  the\r\n * `generateCSS` function.\r\n *\r\n * @param {string} selector: the selector associated with the ruleset\r\n * @param {Object} declarations: a map from camelCased CSS property name to CSS\r\n *     property value.\r\n * @param {Object.<string, function>} stringHandlers: a map from camelCased CSS\r\n *     property name to a function which will map the given value to the value\r\n *     that is output.\r\n * @param {bool} useImportant: A boolean saying whether to append \"!important\"\r\n *     to each of the CSS declarations.\r\n * @returns {string} A string of raw CSS.\r\n *\r\n * Examples:\r\n *\r\n *    generateCSSRuleset(\".blah\", { color: \"red\" })\r\n *    -> \".blah{color: red !important;}\"\r\n *    generateCSSRuleset(\".blah\", { color: \"red\" }, {}, false)\r\n *    -> \".blah{color: red}\"\r\n *    generateCSSRuleset(\".blah\", { color: \"red\" }, {color: c => c.toUpperCase})\r\n *    -> \".blah{color: RED}\"\r\n *    generateCSSRuleset(\".blah:hover\", { color: \"red\" })\r\n *    -> \".blah:hover{color: red}\"\r\n */\n\n\nvar generateCSSRuleset = function generateCSSRuleset(selector, declarations, stringHandlers, useImportant) {\n  var handledDeclarations = runStringHandlers(declarations, stringHandlers);\n  var prefixedDeclarations = (0, _inlineStylePrefixerStatic2['default'])(handledDeclarations);\n  var prefixedRules = (0, _util.flatten)((0, _util.objectToPairs)(prefixedDeclarations).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    var key = _ref2[0];\n    var value = _ref2[1];\n\n    if (Array.isArray(value)) {\n      var _ret = function () {\n        // inline-style-prefix-all returns an array when there should be\n        // multiple rules, we will flatten to single rules\n        var prefixedValues = [];\n        var unprefixedValues = [];\n        value.forEach(function (v) {\n          if (v.indexOf('-') === 0) {\n            prefixedValues.push(v);\n          } else {\n            unprefixedValues.push(v);\n          }\n        });\n        prefixedValues.sort();\n        unprefixedValues.sort();\n        return {\n          v: prefixedValues.concat(unprefixedValues).map(function (v) {\n            return [key, v];\n          })\n        };\n      }();\n\n      if (typeof _ret === 'object') return _ret.v;\n    }\n\n    return [[key, value]];\n  }));\n  var rules = prefixedRules.map(function (_ref3) {\n    var _ref32 = _slicedToArray(_ref3, 2);\n\n    var key = _ref32[0];\n    var value = _ref32[1];\n    var stringValue = (0, _util.stringifyValue)(key, value);\n    var ret = (0, _util.kebabifyStyleName)(key) + ':' + stringValue + ';';\n    return useImportant === false ? ret : (0, _util.importantify)(ret);\n  }).join(\"\");\n\n  if (rules) {\n    return selector + '{' + rules + '}';\n  } else {\n    return \"\";\n  }\n};\n\nexports.generateCSSRuleset = generateCSSRuleset;","map":null,"metadata":{},"sourceType":"script"}